//! Simulation result types for Qublis‐sim — Qublis v2.0
//!
//! Defines the core data structures returned by the various simulators,
//! and the aggregated `ReportData`.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Result of a TPS (transactions‐per‐second) simulation.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TpsResult {
    /// Target TPS from the configuration.
    pub target_tps: u64,
    /// Achieved average TPS over the run.
    pub average_tps: f64,
    /// Time‐series of (timestamp_sec, instantaneous_tps).
    pub samples: Vec<(u64, f64)>,
}

/// Multi‐dimensional view of resource utilization.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DimensionView {
    /// Number of dimensions modeled.
    pub dimensions: usize,
    /// Map from a dimension index (0..dimensions) to its utilization metric.
    pub utilization: HashMap<usize, f64>,
}

/// Latency profile generated by the latency_wave simulator.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LatencyProfile {
    /// Mean latency (ms) used for the model.
    pub mean_ms: f64,
    /// Standard deviation (ms) used for the model.
    pub stddev_ms: f64,
    /// Samples of (timestamp_sec, observed_latency_ms).
    pub samples: Vec<(u64, f64)>,
}

/// Result of a NeuroFlux optimization simulation.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NeuroFluxResult {
    /// Number of iterations performed.
    pub iterations: usize,
    /// Best reward or performance metric achieved.
    pub best_metric: f64,
    /// Time‐series of (iteration, metric_value).
    pub progress: Vec<(usize, f64)>,
}

/// Aggregated network statistics from the full network simulator.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NetworkStats {
    /// Total number of nodes simulated.
    pub node_count: usize,
    /// Total messages routed.
    pub messages_routed: u64,
    /// Average end‐to‐end latency (ms).
    pub average_latency_ms: f64,
    /// Packet drop rate (0.0–1.0).
    pub drop_rate: f64,
}

/// Final report data bundling all simulation components.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReportData {
    /// TPS simulation results.
    pub tps: TpsResult,
    /// Dimension utilization view.
    pub dimensions: DimensionView,
    /// Latency profile.
    pub latency: LatencyProfile,
    /// NeuroFlux simulation, if enabled.
    pub neuroflux: Option<NeuroFluxResult>,
    /// Full network statistics.
    pub network: NetworkStats,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tps_result_roundtrip() {
        let res = TpsResult {
            target_tps: 1_000_000,
            average_tps: 950_000.5,
            samples: vec![(0, 900_000.0), (1, 1_000_000.0)],
        };
        let json = serde_json::to_string(&res).unwrap();
        let de: TpsResult = serde_json::from_str(&json).unwrap();
        assert_eq!(de.target_tps, res.target_tps);
        assert!((de.average_tps - res.average_tps).abs() < 1e-6);
        assert_eq!(de.samples.len(), 2);
    }

    #[test]
    fn report_data_contains_all_sections() {
        let report = ReportData {
            tps: TpsResult {
                target_tps: 100,
                average_tps: 95.0,
                samples: vec![],
            },
            dimensions: DimensionView {
                dimensions: 3,
                utilization: [(0, 0.5), (1, 0.75), (2, 0.25)]
                    .iter().cloned().collect(),
            },
            latency: LatencyProfile {
                mean_ms: 50.0,
                stddev_ms: 10.0,
                samples: vec![],
            },
            neuroflux: None,
            network: NetworkStats {
                node_count: 10,
                messages_routed: 1000,
                average_latency_ms: 55.0,
                drop_rate: 0.01,
            },
        };
        let json = serde_json::to_string(&report).unwrap();
        let de: ReportData = serde_json::from_str(&json).unwrap();
        assert_eq!(de.dimensions.dimensions, 3);
        assert!(de.neuroflux.is_none());
        assert_eq!(de.network.node_count, 10);
    }
}
